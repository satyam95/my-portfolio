---
title: "Building Accessible Web Applications with React and Next.js"
description: "A comprehensive guide to implementing accessibility best practices in React and Next.js applications."
image: "https://example.com/images/accessible-web-applications.jpg"
date: "2025-06-02"
---

# Building Accessible Web Applications with React and Next.js

Users with impaired vision or those relying on screen readers can and should be able to navigate a web app without a mouse—but accessibility is often overlooked during development until it’s too late to integrate it efficiently.

When I started building web applications with React and Next.js, I considered accessibility as an afterthought or ignored it. But as I gained experience and started building production-grade apps, I realised how important it is to build accessible apps for everyone, but also important for SEO, user experience, and the reliability of the product.

In this article, I’ll outline important concepts for building accessible apps, such as Semantic HTML, keyboard navigation to ARIA roles, and pre-launch testing. This guide will help you build better, more accessible, and more inclusive web applications.

---

## Why Accessibility Matters in Modern Web Development

During my early days, I heavily focused on functionality, User Interface (UI), and speed. But after some time, I realised my apps are not usable by everyone. Accessibility (often abbreviated as a11y) means ensuring that our apps and websites are usable by as many people as possible, including those with disabilities such as vision impairments, motor limitations, or cognitive challenges.

But to be honest, with legal regulations like the ADA and WCAG 2.1, ignoring accessibility can lead to legal risks, too.

### Key Benefits:

- Improves usability for all users
- Helps SEO (yes, Google bots love accessible pages!)
- Avoids legal issues
- Demonstrates ethical development practices

---

## Semantic HTML: Your First Accessibility Tool

While building components, I often used `<div>` and `<span>` out of habit, until I realized that semantic HTML is the backbone of accessible apps. Screen readers rely on semantic tags to understand page structure.

### Examples I Apply Daily

- Use `<button>` instead of clickable `<div>`
- Use `<nav>`, `<header>`, `<main>`, and `<footer>` for layout
- Use `<ul>` and `<ol>` for lists
- Use `<label htmlFor="inputId">` with form fields

```tsx
<label htmlFor="email">Email</label>
<input id="email" type="email" />
```

---

## Using ARIA Roles Carefully

ARIA (Accessible Rich Internet Applications) roles can improve the experience for users of assistive technologies.

### Best Practices I Follow:

- Prefer native HTML over ARIA whenever possible
- Use `role="alert"` for dynamic errors
- Use `aria-live="polite"` for background updates like notifications
- Use `aria-label`, `aria-labelledby`, or `aria-describedby` for extra context

```tsx
<button aria-label="Close modal">
  <XIcon />
</button>
```

---

## Keyboard Navigation Support

One of the common ways of accessibility testing is navigating the app using only the keyboard (Tab, Shift+Tab, Enter, Escape). Most of the interactive elements, such as modals, dropdowns, and carousels, fail in tests.

### How I Handle It:

- Set logical `tabindex` order (usually let the browser handle it)
- Trap focus inside modals using `focus-trap-react` or custom code
- Return focus to the last active element after modal close
- Avoid removing focus outlines (or use custom focus styles)

```css
button:focus {
  outline: 2px solid #3b82f6;
}
```

---

## Common UI Components and Their Accessible Patterns

Components such as dropdowns, modals, and sliders need extra care. I’ve broken many in the past until I started referencing accessible design patterns from WAI-ARIA Authoring Practices.

### Example Approach for Building Components:

#### Modals

- Trap focus inside modal
- Close on Esc
- Restore focus to the previous element
- Label with `aria-labelledby` and `aria-describedby`

#### Dropdowns

- Use `aria-expanded`, `aria-controls`
- Open/close on Enter/Space
- Arrow key navigation

#### Tabs

- Each tab has `role="tab"`
- Active tab has `aria-selected="true"`
- Panels use `role="tabpanel"`

---

## Testing Accessibility During Development

Testing for accessibility has become non-negotiable for me during the development. The earliest we find these issues, the less painful they are to fix.

### Tools Used

- axe DevTools browser extension
- Lighthouse in Chrome DevTools
- eslint-plugin-jsx-a11y
- Keyboard-only testing
- Screen readers: VoiceOver (Mac), NVDA (Windows)

### React Testing Library + jest-axe

```bash
npm install --save-dev jest-axe @testing-library/react
```

```tsx
import { axe, toHaveNoViolations } from "jest-axe";

expect.extend(toHaveNoViolations);
it("should have no accessibility violations", async () => {
  const { container } = render(<MyComponent />);
  const results = await axe(container);
  expect(results).toHaveNoViolations();
});
```

---

## Accessible Mobile Navigation

While building a responsive navbar, I mainly focus on the layout. But soon I realised that without proper ARIA roles and keyboard support, most mobile navs break for assistive tech.

### Here's What I Include Now:

#### Toggle Button

```tsx
<button
  aria-expanded={isOpen}
  aria-controls="mobile-menu"
  aria-label="Toggle navigation"
  onClick={() => setIsOpen(!isOpen)}
>
  <MenuIcon />
</button>
```

#### Mobile Menu Container

```tsx
<div id="mobile-menu" hidden={!isOpen}>
  <ul>
    <li>
      <a href="/about">About</a>
    </li>
    <li>
      <a href="/services">Services</a>
    </li>
  </ul>
</div>
```

- Keyboard-friendly navigation (focus traps, escape key to close, etc.)

---

## Using Tailwind CSS for Accessibility

Tailwind CSS becomes an integral part of my tech stack as I use it in all of my projects. It doesn't ensure accessibility, but it provides utilities that support it — if you know what to use.

### Useful Utilities:

- `sr-only`: For screen-reader-only content
- `focus:outline-none focus:ring`: Custom yet visible focus states
- `aria-*` support via standard JSX
- `prose`, `leading-relaxed`: For better readability
- `text-contrast`, `bg-opacity-*`, `text-opacity-*` for better color control

#### Example: Skip Link

```tsx
<a href="#main-content" className="sr-only focus:not-sr-only">
  Skip to main content
</a>
```

---

## How I Audit a Production App Before Launch

I have published/deployed multiple apps to know that accessibility bugs often hide until the end. That's why I always perform manual audits before deploying apps to production.

### Pre-Launch Accessibility Checklist

#### Structural Checks

- Proper heading levels (no jumping from h1 to h3)
- Landmark regions: `<main>`, `<nav>`, `<footer>`, etc.
- Forms have labels and error feedback

#### Keyboard Testing

- All interactive elements reachable via Tab
- No keyboard traps (especially modals, dropdowns)
- Focus styles visible and intuitive

#### Screen Reader Testing

- Use VoiceOver (Mac) or NVDA (Windows)
- Ensure nav, buttons, and alerts are announced properly

#### Lighthouse and axe-core

- Run Lighthouse’s a11y audit
- Use axe browser extension for in-browser checks

#### Color and Contrast

- Use tools like Stark or WebAIM
- Verify dark mode doesn’t reduce readability

#### ARIA and Roles

- Validate `aria-*` attributes
- Avoid redundant roles or unnecessary ARIA

---

## Final Thoughts

While building React and Next.js apps, accessibility should not be the thing that can be added later – it is the thing that is included from the start. Use semantic HTML, test keyboard navigation, announce page changes properly, and audit your UI regularly. Trust me — your users (and your future self) will thank you.
